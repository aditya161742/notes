Coding interview questions 

Below are the patterns they ask from:

1ï¸âƒ£ Frequency Pattern
2ï¸âƒ£ Two Pointer Pattern
3ï¸âƒ£ Sliding Window
4ï¸âƒ£ Sort + Solve
5ï¸âƒ£ Recursion
6ï¸âƒ£ Binart search tree

Today we start with:


---

ğŸ¥‡ FREQUENCY PATTERN â€” MASTER CLASS

ğŸ” HOW TO RECOGNIZE FREQUENCY PROBLEMS

The problem statement contains words like:

	count

	frequency

	how many times

	first unique

	duplicates

	anagram (example : earth" â†’ "heart," "debit card" â†’ "bad credit,")

	repeating


Or logically you feel:

> I need to know how often something appears.



That moment â†’ HashMap.


---

ğŸ¯ STRUCTURE OF EVERY FREQUENCY SOLUTION

	Always 2 passes:


	---

	PASS 1 â€” Count

	Loop input and count:

	element â†’ count


	---

	PASS 2 â€” Decide

	Loop again and apply rule:

	first count == 1

	count > 1

	etc

---

ğŸ§© PROBLEM 1 â€” First Non-Repeating Character

	Input:

	javaiseasy


---

	THINK (not code):

	Step 1
	Count:

	j=1
	a=3
	v=1
	i=1
	s=2
	e=1
	y=1


	---

	Step 2
	Traverse original string:

	j â†’ count 1 â†’ STOP

	Answer: j

---

So tool:

	> LinkedHashMap (if order needs to persist)

---

ğŸ§© PROBLEM 2 â€” Find duplicates

	Input:

	[a,b,c,a,b]

---

Think:

	Count first.

	Then print elements where count > 1.

	Same pattern.
	
---

ğŸ§© PROBLEM 3 â€” Anagram

	"listen" vs "silent"

---

Think:

	Count characters of both strings.

	Compare maps.

	Same pattern.

---

ğŸ§© PROBLEM 4 â€” Two Sum

[2,7,11,15], target=9

	Example:
		
		Logic:
		
			For each number, compute the complement:

			complement = target - nums[i]


			If the complement exists in the map â†’ we found the pair.

			Otherwise, store the current number in the map.

		Solution:
		
			Map<Integer, Integer> map = new HashMap<>();
        
			for (int i = 0; i < nums.length; i++) {
				int complement = target - nums[i];
				
				if (map.containsKey(complement)) {
					return new int[] { map.get(complement), i };
				}
				
				map.put(nums[i], i);
			}
			
			throw new IllegalArgumentException("No two sum solution");

---

Think:

Store seen numbers.

For each number: target - current

Check in map.

Again frequency.

---

ğŸ§  WHICH DATA STRUCTURE?

Situation	Use

Order matters	LinkedHashMap
Order doesn't matter	HashMap

------------------------------

ğŸ¥ˆ TWO POINTER PATTERN â€” MASTER CLASS

---

ğŸ§  CORE IDEA (one line)

> Use two indices moving toward each other (or same direction) instead of nested loops.

---

ğŸ” HOW TO RECOGNIZE TWO POINTER PROBLEMS

Youâ€™ll usually see:

	Reverse something

	Palindrome check

	Compare from both ends

	Sorted array + find pair

	Move zeros

	Remove duplicates

---

ğŸ¯ STRUCTURE OF TWO POINTER

	You create:

		left = 0
		right = n-1

	Then:

		while(left < right){
		   compare / swap
		   left++
		   right--
		}

Thatâ€™s the whole pattern.

---

ğŸ§© PROBLEM 1 â€” Reverse String

Input:

	java

---

THINK (not code):

	j a v a
	â†‘     â†‘
	swap

	a a v j
	  â†‘ â†‘
	swap

	done

---

ğŸ§© PROBLEM 2 â€” Palindrome

Input:

	madam

---

Think:

	Compare:

	m == m
	a == a

	Continue until pointers meet.

	If mismatch â†’ not palindrome.

---

ğŸ§© PROBLEM 3 â€” Move zeros to end

	[0,1,0,3,12]

---

Goal:

	[1,3,12,0,0]

---

Think:

	One pointer tracks next non-zero
	Other scans array.

	Still two pointers.

	Example:
	
		int left = 0;  // position for next non-zero

        for (int right = 0; right < nums.length; right++) {
            if (nums[right] != 0) {
                // swap nums[left] and nums[right]
                int temp = nums[left];
                nums[left] = nums[right];
                nums[right] = temp;

                left++;
            }
        }
		
	Step by step output:
	
		right	nums[right]	left	Array State
		
		0	    0		 	0		[0,1,0,3,12]
		1		1			0		swap â†’ [1,0,0,3,12], left=1
		2		0			1		no change
		3		3			1		swap â†’ [1,3,0,0,12], left=2
		4		12			2		swap â†’ [1,3,12,0,0], left=3

---

ğŸ§© PROBLEM 4 â€” Two Sum (sorted array)

[1,3,4,6,8]
target=7


---

Think:

1 + 8 = 9 â†’ too big â†’ move right
1 + 6 = 7 â†’ found

---------------------------

---

ğŸ¥‰ SLIDING WINDOW â€” MASTER CLASS


---

ğŸ§  CORE IDEA (one line)

> Maintain a moving window over continuous data, expand it, shrink it, and track the best result.

Unlike two pointers (which usually move from ends), sliding window works on:

ğŸ‘‰ continuous segments

---

ğŸ” HOW TO RECOGNIZE SLIDING WINDOW

The problem statement contains words like:

	longest

	shortest

	substring

	subarray

	continuous

	window

	max/min in range

---

ğŸ¯ STRUCTURE (MENTAL TEMPLATE)

	You always have:

		left = 0
		right = 0

	Then:

		expand right
		check condition
		if invalid â†’ shrink left
		update answer

	Thatâ€™s the whole pattern.


---

ğŸ§  VISUAL MODEL

	Imagine a glass window moving over data:

	j a v a i s e a s y
	^       ^
	left    right

	You:

	grow window by moving right

	fix window by moving left

	track max/min

---

ğŸ§© PROBLEM 1 â€” Longest Non-Repeating Substring

	Input:

	javaiseasy

	Goal:

	vaise


	---

	THINKING (NO CODE)

	Start empty window.


	---

	Step 1

	Add j

	Window: j


	---

	Step 2

	Add a

	Window: ja


	---

	Step 3

	Add v

	Window: jav


	---

	Step 4

	Add a

	Oops â€” duplicate a.

	So:

	Move LEFT until a removed.

	Window becomes:

	va

	Then continue.


---

You repeat:

expand right

if duplicate â†’ shrink left

update max length

---

ğŸ§© PROBLEM 2 â€” Max sum subarray of size K

[2,1,5,1,3,2], K=3


---

	Window size fixed = 3

	Slide:

	[2,1,5] sum=8
	[1,5,1] sum=7
	[5,1,3] sum=9
	[1,3,2] sum=6

	Max = 9

	Same pattern.
	
---

ğŸ§© PROBLEM 3 â€” Smallest subarray with sum â‰¥ target

Again:

	expand right until sum â‰¥ target

	shrink left to minimize

	track smallest


	Sliding window.


---

ğŸ›  TOOLS USED

Depending on problem:

	HashSet (uniqueness)

	HashMap (frequency inside window)

	Sum variable

----------------------

ğŸ—ï¸ SORT + SOLVE PATTERN â€” MASTER CLASS
	
	This one is very common in second highest, kth element, interval problems, etc.

ğŸ§  CORE IDEA (one line)

	Sort the data first, then apply simple logic.

Sorted :

	Integer and character sort:

	for i from 0 to n:
	   for j from i+1 to n:
		   if arr[i] > arr[j]:
			   swap(arr[i], arr[j])

String sort:

	Only if condition changes

	-> if(str[i].compareTo(str[j]) > 0)

	Example: 

	"cat".compareTo("bat")   // positive â†’ cat > bat
	"ant".compareTo("bat")   // negative â†’ ant < bat


Merge Overlapping Intervals

Example:

	Input: [1,3], [2,6], [8,10]
	After sorting: [1,3], [2,6], [8,10]

	Now compare neighbors:
	[1,3] overlaps [2,6] â†’ merge â†’ [1,6]
	[1,6] does NOT overlap [8,10]

	Final: [1,6], [8,10]

------------------------------

ğŸ” RECURSION â€” MASTER CLASS


ğŸ§  CORE IDEA (one line)

> Solve a problem by solving a smaller version of the same problem.

---

ğŸ¯ Every recursive solution has ONLY TWO parts

You must memorize this:

---

1ï¸) Base Case (STOP)

	When recursion should end.

	Example:

	if(n == 0) return;
	
---

2ï¸) Recursive Case (REDUCE)

	Call same function with smaller input.

	Example:

	func(n-1);

---

If either is missing â†’ infinite recursion â†’ stack overflow.


---

ğŸ§  UNIVERSAL TEMPLATE

Every recursion follows:

	if(base case)
	   return;

	do something

	call same function with smaller problem

Thatâ€™s it.


---

ğŸ” HOW TO RECOGNIZE RECURSION PROBLEMS

Youâ€™ll hear:

	factorial

	fibonacci

	reverse recursively

	tree traversal

	permutations

	combinations
	
---

ğŸ§© PROBLEM 1 â€” Factorial

	5! = 5 * 4!
	4! = 4 * 3!
	...
	1! = 1   â† base

	Pattern:

		base: n==1

		recursive: n * fact(n-1)

---

ğŸ§© PROBLEM 2 â€” Reverse String

	Input:

	java

	Think:

		reverse("java")
		= reverse("ava") + "j"

		Keep reducing until empty.

---

ğŸ§© PROBLEM 3 â€” Fibonacci

	fib(n) = fib(n-1) + fib(n-2)

	Base:

		fib(0)=0
		fib(1)=1

---

Problem 4: sort int[] array using recursion 

	sort(arr, n):
	   if n == 1 â†’ done

	   find max in first n
	   swap with last

	   sort(arr, n-1)
---

---------------------------
 Binary search tree:

Core pseudo code:

	function insert(root, value):

		if root is null:
			return new Node(value)

		if value < root.value:
			root.left = insert(root.left, value)
		else:
			root.right = insert(root.right, value)

		return root

------------------------

Perfect â€” now that youâ€™ve learned the patterns, hereâ€™s a focused practice set (moderate â†’ moderately hard) that maps directly to what service-company + client rounds usually test.

Donâ€™t try to solve everything at once.
Do 10â€“12 well, explaining your pattern choice out loud.

---

ğŸ¯ Pattern-Based Interview Practice Set (Moderate â†’ Difficult)

ğŸ¥‡ Frequency Pattern (HashMap / Counting)

	1. First non-repeating character in a string


	2. Find all duplicates in an array


	3. Check if two strings are anagrams


	4. Group anagrams (list of strings)


	5. Two Sum (unsorted array)


	6. Longest palindrome that can be built from a string


	7. Top K frequent elements



	ğŸ‘‰ Goal: master count â†’ decide


---

ğŸ¥ˆ Two Pointer

	8. Reverse a string / char array in place


	9. Check palindrome (ignore case + non-alphanumerics)


	10. Move zeros to end (in-place)


	11. Remove duplicates from sorted array


	12. Two Sum (sorted array)


	13. 3Sum (find triplets = 0)



	ğŸ‘‰ Goal: master ends move / inward logic


---

ğŸ¥‰ Sliding Window

	14. Longest substring without repeating characters


	15. Longest substring with at most K distinct characters


	16. Maximum sum subarray of size K


	17. Minimum window substring (classic)


	18. Smallest subarray with sum â‰¥ target



	ğŸ‘‰ Goal: master expand right â†’ shrink left


---

ğŸ—ï¸ Sort + Solve

	19. Second largest / kth largest element


	20. Merge overlapping intervals


	21. Insert interval


	22. Find closest pair to target after sorting


	23. Sort characters in a string (manual logic)



	ğŸ‘‰ Goal: master sort â†’ index / neighbor / merge / two pointers


---

ğŸ” Recursion

	24. Reverse string recursively


	25. Factorial / Fibonacci


	26. Print all subsets of a string


	27. Permutations of a string


	28. Height of binary tree



	ğŸ‘‰ Goal: master base + reduce

---

ğŸŒ³ Light Tree (optional but good)

	33. Inorder / Preorder / Postorder traversal


	34. Validate Binary Search Tree


	35. Lowest Common Ancestor (basic)

---